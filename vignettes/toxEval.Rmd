---
title: "Introduction to toxEval: Passive Data"
author: "Steven R. Corsi, Laura A. De Cicco"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    fig_caption: yes
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Passive Data: ToxCast}
  \usepackage[utf8]{inputenc}
---


```{r setup, include=FALSE}
options(continue=" ")
options(width=100)
library(knitr)
library(rmarkdown)
library(dplyr)
library(reshape2)
library(DT)

```

# Introduction

This package **toxEval** is an early test version of the package that will encompass the various approaches to evaluate ToxCast data in relation to measured aquatic concentrations.

Data measured in aquatic environments can come in many different formats. This package will use example data measured from passive samplers, as well as water samples taken at a variety of sites around the Great Lakes. 

# Passive Data
Passive data was returned from the laboratory in a 'long' format. A sample of the data is shown below:

```{r echo=FALSE, eval=TRUE}

packagePath <- system.file("extdata", package="toxEval")
filePath <- file.path(packagePath, "passiveData.RData")
load(file=filePath)
#Site Info:
filePath <- file.path(packagePath, "stationINFO.RData")
load(file=filePath)
#parameter info:
filePath <- file.path(packagePath, "pCodeInfo.RData")
load(file=filePath)

#passive class info:
passiveCAS <- readRDS(file.path(packagePath, "passiveCAS.rds"))

pCodeInfo <- pCodeInfo[pCodeInfo$casrn != "", ]

# Some chemicals have 2 rows (different units)...
# To simplify for now, we'll ignore the duplicate chemicals:


passiveData <- left_join(passiveData, passiveCAS, by=c("CAS", "Chemical"))
passiveData <- passiveData[!duplicated(passiveData$CAS),]
passiveData$class[passiveData$Chemical == "Hexachlorobenzene (HCB)"] <-"OC Pesticides"
passiveData$class[passiveData$Chemical == "Pentachloroanisole (PCA)"] <-"OC Pesticides"
passiveData$class[is.na(passiveData$class)] <-"Pharmaceuticals"

passiveData <- passiveData[,-which(names(passiveData) == "site04249000.1")]

head(passiveData[,1:7])

# Unique units:
unique(passiveData$Units)

```

For this data, the CAS column was used to retrieve the molecular weight (mlWt). Each column is a unique site where the data was collected. Each row is a unique measured chemical. 

Some of the data is 'left-censored'. This means that the measured data was lower than the detection limit of the measurement technique. Values that are found to be lower than the detection limit are indicated by a "<". The first thing to check is that the method quantitation limit (MQL) or minimum level of detectability (MLD) are low enough to be ignored. That is, MQL and MLD are below the minumum endpoint levels. If so, we can simply remove any values that have the "<" indicator. To begin the study of the endpoints and how they relate to our data, we need to load up the **toxEval** package, and choose an endpoint dataset. We will use the AC50gain dataset in this report.

For this workflow, we will use the units reported by the measured data, meaning we need to convert the ToxCast end points to the units in the "Units" column of the passiveData data frame (we could also do the analysis converting the measured data to $\log$$\mu$M... it shouldn't matter as long as you are consistent).

```{r message=FALSE}
library(toxEval)
endPointInfo <- endPointInfo
# AC50 data provided in the toxEval package:
AC50gain <- AC50gain
head(AC50gain[,1:5])

```

The units in the AC50gain, AC50loss, and AC10 data sets are $\log$$\mu$M. The first step is to convert to the desired unit (`r unique(passiveData$Units)`) based on the passiveData data frame.

$$
\require{cancel}
\begin{aligned}
Reported Data = \log \mu M \\
\mu M = 10^{\log \mu M} \\
MW = \frac{g}{mol} , M = \frac{mol}{L}  \\
\cancel{\mu M} \left[\frac{\cancel{M}}{10^6 \cancel{\mu M}}\right] \left[\frac{1}{\cancel{M}}  \frac{\cancel{mol}}{L}\right] \left[ \frac{MW \cancel{g}}{\cancel{mol}}\right] \left[\frac{10^9 ng}{\cancel{g}}\right] = MW * 10^3 \frac{ng}{L} 
\end{aligned}
$$

```{r message=FALSE}
library(dplyr)

unitConversion <- setNames(c(10^6, 10^3), c("pg/L", "ng/L") )

AC50 <- right_join(AC50gain[,c("casn"), drop=FALSE], 
                   passiveData[,c("CAS", "Units", "mlWt","Chemical")],
                   by= c("casn" = "CAS")) %>%
  rename(desiredUnits = Units, chnm=Chemical) %>%
  filter(!is.na(mlWt)) %>%
  mutate(conversion = unitConversion[desiredUnits] * mlWt) %>%
  select(casn, chnm, desiredUnits, mlWt, conversion)


```

A sample of the AC50 data frame is shown here:

```{r echo=FALSE}
kable(head(AC50), digits=2, row.names = FALSE)

```

################################
Same for all vignettes?
################################

Next we can create a data frame with the AC50 converted endpoints:
```{r}
AC50Converted <- left_join(AC50, AC50gain, by = c("casn", "chnm"))
infoColumns <- c("casn", "chnm", "desiredUnits","mlWt", "conversion", "code","chid")

endPointData <- AC50Converted[,!(names(AC50Converted) %in% infoColumns)]
endPointData <- 10^endPointData
endPointData <- endPointData * AC50Converted$conversion
endPoint <- cbind(AC50, data.frame(endPointData))
endPoint <- rename(endPoint, Units=desiredUnits)

```

First, let's look at the extreme reported endpoint (not including `r NA`'s...that will actually may be important):

```{r warning=FALSE}
maxEndPoints <- apply(endPointData, 1, max, na.rm=TRUE) 
minEndPoints <- apply(endPointData, 1, min, na.rm=TRUE)

maxMinSummary <- cbind(endPoint[,c("chnm", "casn", "Units")], 
                       maxEndPoint=maxEndPoints, 
                       minEndPoint=minEndPoints)
siteColumns <- grep("site",names(passiveData))
maxMinSummary <- left_join(maxMinSummary,passiveData[,-siteColumns], 
                           by=c("casn"="CAS", "Units"="Units")) 

```


## Water Sample Detection Levels

For now, we'll focus on the minimum detection level:
```{r warning=FALSE, echo=FALSE}
dfToPrint <- mutate(maxMinSummary, MLD_EAR = MLD/minEndPoint) %>%
  select(Chemical, minEndPoint, MLD, MLD_EAR, class) %>%
  arrange(desc(MLD_EAR)) %>%
  rename("maxEAR"=MLD_EAR)%>%
  filter(maxEAR > 0.01) 
  
datatable(dfToPrint, rownames=FALSE) %>% 
    formatRound(c("maxEAR","MLD","minEndPoint"), digits = 3)

```


```{r}
siteColumns <- grep("site",names(passiveData))
passiveData[,siteColumns] <- suppressWarnings(
  sapply(passiveData[,siteColumns], function(x) as.numeric(x)))

#For this analysis, we'll consider NA's to be 0 (other options exist):
passiveData[,siteColumns][is.na(passiveData[,siteColumns])] <- 0

```


## Chemical Summary Tables: Water Samples

### Overall
```{r message=FALSE, results='asis', echo=FALSE}
newSiteKey <- setNames(stationINFO$shortName, stationINFO$fullSiteID)

infoColumns <- c("Chemical", "CAS", "Units", "MLD", "MQL", "mlWt","class")

chemicalSummary <- melt(passiveData, id.vars = infoColumns) %>%
  mutate(variable=as.character(variable)) %>%
  filter(!is.na(value)) %>%
  select(srsname=Chemical,
         casrn=CAS,
         class=class,
         measuredValue=value, 
         site=variable) %>%
  right_join(endPoint, by=c("casrn"="casn")) %>%
  select(-mlWt, -conversion, -casrn,  -Units, -srsname) %>%
  melt(id.vars = c("class", "site", "measuredValue","chnm")) %>% 
  filter(!is.na(value)) %>%
  mutate(variable=as.character(variable)) %>%
  rename(endPointValue=value, endPoint=variable) %>%
  mutate(EAR=measuredValue/endPointValue) 

chemSum1 <- chemicalSummary %>%
  group_by(chnm,  class, site) %>%
  summarize(hits= as.numeric(any(EAR > 0.1))) %>%
#   group_by(chnm,  class, site) %>%
#   summarize(hits=as.numeric(any(hits > 0))) %>%
  group_by(chnm, class) %>%
  summarize(freq=sum(hits)/length(unique(site)),
            nSites=sum(hits)) 

chemSum2 <- chemicalSummary %>%
  group_by(chnm,  class) %>%  
  summarize(maxEAR=max(EAR), 
            nSamples=1,
            nEndPoints=length(unique(endPoint[EAR > 0.1]))) %>%
  left_join(chemSum1, by=c("chnm","class")) %>%
  data.frame %>%
  arrange(desc(freq)) %>%
  select(chnm, class, freq, maxEAR, nEndPoints, nSites, nSamples)

  datatable(chemSum2, rownames = FALSE, 
            options = list(pageLength = 10)) %>% 
    formatRound(c("maxEAR", "freq"), digits = 4)


```

### Individual EndPoints
Looking at individual endpoints (filtering only rows that have some hit):

```{r message=FALSE, results='asis', echo=FALSE}

chemSum2 <- chemicalSummary  %>%
  group_by(chnm, endPoint, class) %>% 
  summarize(maxEAR=max(EAR), 
            nSites=length(unique(site[EAR>0.1]))) %>%
#This line adds rows because there are repeated endpoints in the endPointInfo table (maybe unique this table at the end to see if it matters)
  left_join(endPointInfo, by=c("endPoint"="assay_component_endpoint_name")) %>% 
  select(chnm, maxEAR, nSites, 
         endPoint, class, contains("intended_target_")) %>%
  rename(type=intended_target_type, type_sub=intended_target_type_sub,
         family=intended_target_family, family_sub=intended_target_family_sub) %>%
  select(-contains("intended_target_"))  %>%
  data.frame %>%
  filter(maxEAR > 0.1) %>%
  arrange(desc(maxEAR))  

  datatable(unique(chemSum2), rownames = FALSE, 
            options = list(pageLength = 10)) %>% 
    formatRound(c("maxEAR"), digits = 2)

```

## Site Summaries: Water Samples

The first site summary table groups only by site:

```{r message=FALSE, results='asis', echo=FALSE}

infoColumns <- c("Chemical", "CAS", "Units", "MLD", "MQL", "mlWt","class")

siteSummary <- melt(passiveData, id.vars = infoColumns) %>%
  mutate(variable=as.character(variable)) %>%
  filter(!is.na(value)) %>%
  select(srsname=Chemical,
         casrn=CAS,
         class=class,
         measuredValue=value, 
         site=variable) %>%
  right_join(endPoint, by=c("casrn"="casn")) %>%
  select(-mlWt, -conversion, -casrn,  -Units, -srsname) %>%
  melt(id.vars = c("class", "site", "measuredValue","chnm")) %>% 
  filter(!is.na(value)) %>%
  mutate(variable=as.character(variable)) %>%
  rename(endPointValue=value, endPoint=variable) %>%
  mutate(EAR=measuredValue/endPointValue) %>%
  mutate(site=newSiteKey[paste0("USGS-",gsub("[^0-9]", "", site))]) %>%
  select(site, chnm, EAR, endPoint, class) %>% 
  arrange(site, chnm, EAR)

summ1 <- siteSummary %>%
  group_by(site) %>%
  summarize(hits= as.numeric(any(EAR > 0.1)),
            nChem = length(unique(chnm[EAR > 0.1])),
            nEndPoints = length(unique(endPoint[EAR > 0.1])),
            maxEAR = max(EAR))%>%
  arrange(desc(maxEAR))



datatable(summ1, rownames = FALSE) %>% 
#           options = list(pageLength = 50)) %>% 
  formatRound(c("maxEAR"), digits = 2)

```




















































