<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction to toxEval</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Introduction to toxEval}
-->

<h1>Introduction to toxEval</h1>

<p>By Laura A. De Cicco, Steven Corsi</p>

<p>This package <strong>toxEval</strong> is an early test version of the package that will encompass the various approaches to evaluate ToxCast data in relation to measured aquatic concentrations.</p>

<h2>Molecular weights</h2>

<p>ToxCast reports values in \(\log\)$\mu$M. Data from water samples collected are typically mg/L, ng/L, or pg/L. Therefore, the first step is to determine the molecular weight of the measured data. The package <strong>webchem</strong> supports this functionality. </p>

<pre><code class="r">library(&quot;webchem&quot;)

inchk &lt;- cts_convert(query = &#39;3380-34-5&#39;, from = &#39;CAS&#39;, to = &#39;inchikey&#39;)
info &lt;- cts_compinfo(inchikey = inchk)
info$molweight
</code></pre>

<pre><code>## [1] 289.5418
</code></pre>

<h2>Workflow</h2>

<p>Data measured in aquatic environments can come in many different formats. This package will use example data measured from passive samplers, as well as water samples taken at a variety of sites around the Great Lakes. </p>

<h3>Passive Data:</h3>

<p>Passive data was returned from the laboratory in a &#39;long&#39; format. A sample of the data is shown below:</p>

<pre><code class="r">packagePath &lt;- system.file(&quot;extdata&quot;, package=&quot;toxEval&quot;)
filePath &lt;- file.path(packagePath, &quot;passiveData.RData&quot;)
load(file=filePath)

head(passiveData[,1:8])
</code></pre>

<pre><code>##                    Chemical Units MLD  MQL site04101500 site04102500 site04108660 site04119400
## 1               Trifluralin  pg/L 190  490         &lt;190         &lt;190         &lt;190         &lt;190
## 2   Hexachlorobenzene (HCB)  pg/L  32   88          130           49           33          &lt;32
## 3  Pentachloroanisole (PCA)  pg/L  69  210          150          160           93           86
## 4                Tefluthrin  pg/L 130  380         &lt;130         &lt;130         &lt;130         &lt;130
## 5 alpha-Benzenehexachloride  pg/L 190  570         &lt;190         &lt;190         &lt;190         &lt;190
## 6                   Lindane  pg/L 850 2400         &lt;850         &lt;850         &lt;850         &lt;850
</code></pre>

<pre><code class="r"># Unique units:
unique(passiveData$Units)
</code></pre>

<pre><code>## [1] &quot;pg/L&quot; &quot;ng/L&quot;
</code></pre>

<p>For this data, the CAS column was used to retrieve the molecular weight (mlWt). Each column is a unique site where the data was collected. Each row is a unique measured chemical. The data may be &#39;left-censored&#39;. This means that the measured data was lower than the detection limit of the measurement technique. Values that are found to be lower than the detection limit are indicated by a &ldquo;&lt;&rdquo;.</p>

<p>Because of the &ldquo;&lt;&rdquo;, the measured data is currently a vector of characters. The simpliest way to convert that data to numbers is to use the <code>as.numeric</code> function. This will convert the left-censored data to <code>NA</code>, generating a warning. We can discuss more vigorious methods for dealing with censored values in future sections. To convert all the columns with the word &#39;site&#39; in their column name, use the following commands:</p>

<pre><code class="r">siteColumns &lt;- grep(&quot;site&quot;,names(passiveData))
passiveData[,siteColumns] &lt;- sapply(passiveData[,siteColumns], function(x) as.numeric(x))

# #Let&#39;s remove rows that now have all NA&#39;s:
# passiveData &lt;- passiveData[rowSums(is.na(passiveData[,siteColumns]))!=length(siteColumns) ,]
</code></pre>

<p>For this workflow, we will use the units reported by the measured data, meaning we need to convert the ToxCast end points to the units in the &ldquo;Units&rdquo; column of the passiveData data frame (we could also do the analysis converting the measured data to \(\log\)$\mu$M&hellip; it shouldn&#39;t matter as long as you are consistent).</p>

<pre><code class="r">library(toxEval)

# AC50 data provided in the toxEval package:
AC50gain &lt;- AC50gain

head(AC50gain[,1:5])
</code></pre>

<pre><code>##        code  chid       casn                     chnm ACEA_T47D_80hr_Negative
## 1   C100005 20281   100-00-5  1-Chloro-4-nitrobenzene                      NA
## 2   C100016 20961   100-01-6           4-Nitroaniline                1.120699
## 3   C100027 21834   100-02-7            4-Nitrophenol                      NA
## 4 C10016203 30698 10016-20-3       alpha-Cyclodextrin                      NA
## 5   C100210 26080   100-21-0        Terephthalic acid                      NA
## 6 C10025748 41909 10025-74-8 Dysprosium(III) chloride                      NA
</code></pre>

<p>The units in the AC50gain, AC50loss, and AC10 data sets are in \(\log\)$\mu$M. The first step is to convert to the desired unit (pg/L, ng/L)</p>

<p>First, let&#39;s merge the desired units to the data frame:</p>

<p>\[
\require{cancel}
\begin{aligned}
Reported Data = \log \mu M \
\mu M = 10^{\log \mu M} \
MW = \frac{g}{mol} , M = \frac{mol}{L}  \
\cancel{\mu M} \left[\frac{\cancel{M}}{10^6 \cancel{\mu M}}\right] \left[\frac{1}{\cancel{M}}  \frac{\cancel{mol}}{L}\right] \left[ \frac{MW \cancel{g}}{\cancel{mol}}\right] \left[\frac{10^9 ng}{\cancel{g}}\right] = MW * 10^3 \frac{ng}{L} 
\end{aligned}
\]</p>

<pre><code class="r">library(dplyr)

unitConversion &lt;- setNames(c(10^6, 10^3), c(&quot;pg/L&quot;, &quot;ng/L&quot;) )

AC50 &lt;- left_join(AC50gain, passiveData[,c(&quot;CAS&quot;, &quot;Units&quot;, &quot;mlWt&quot;)],
                   by= c(&quot;casn&quot; = &quot;CAS&quot;)) %&gt;%
  filter(!is.na(Units)) %&gt;%
  rename(desiredUnits = Units) %&gt;%
  mutate(conversion = unitConversion[desiredUnits] * mlWt) %&gt;%
  select(casn, chnm, desiredUnits, mlWt, conversion)
</code></pre>

<p>A sample of the AC50 data frame is shown here:</p>

<table><thead>
<tr>
<th align="left">casn</th>
<th align="left">chnm</th>
<th align="left">desiredUnits</th>
<th align="right">mlWt</th>
<th align="right">conversion</th>
</tr>
</thead><tbody>
<tr>
<td align="left">101-20-2</td>
<td align="left">Triclocarban</td>
<td align="left">ng/L</td>
<td align="right">315.5859</td>
<td align="right">315585.9</td>
</tr>
<tr>
<td align="left">1024-57-3</td>
<td align="left">Heptachlor epoxide</td>
<td align="left">pg/L</td>
<td align="right">389.3199</td>
<td align="right">389319900.0</td>
</tr>
<tr>
<td align="left">1031-07-8</td>
<td align="left">Endosulfan sulfate</td>
<td align="left">pg/L</td>
<td align="right">422.9220</td>
<td align="right">422922000.0</td>
</tr>
<tr>
<td align="left">103-90-2</td>
<td align="left">Acetaminophen</td>
<td align="left">ng/L</td>
<td align="right">151.1646</td>
<td align="right">151164.6</td>
</tr>
<tr>
<td align="left">106-46-7</td>
<td align="left">1,4-Dichlorobenzene</td>
<td align="left">pg/L</td>
<td align="right">147.0036</td>
<td align="right">147003600.0</td>
</tr>
<tr>
<td align="left">108-95-2</td>
<td align="left">Phenol</td>
<td align="left">pg/L</td>
<td align="right">94.1128</td>
<td align="right">94112800.0</td>
</tr>
</tbody></table>

<p>Next we can create a data frame with the AC50 converted endpoints:</p>

<pre><code class="r">AC50Converted &lt;- left_join(AC50, AC50gain)
</code></pre>

<pre><code>## Joining by: c(&quot;casn&quot;, &quot;chnm&quot;)
</code></pre>

<pre><code class="r">infoColumns &lt;- c(&quot;casn&quot;, &quot;chnm&quot;, &quot;desiredUnits&quot;,&quot;mlWt&quot;, &quot;conversion&quot;, &quot;code&quot;,&quot;chid&quot;)

endPointData &lt;- AC50Converted[,!(names(AC50Converted) %in% infoColumns)]
endPointData &lt;- 10^endPointData
endPointData &lt;- endPointData * AC50Converted$conversion
endPoint &lt;- cbind(AC50, data.frame(endPointData))
endPoint &lt;- rename(endPoint, Units=desiredUnits)
</code></pre>

<p>First, let&#39;s look at the extreme reported endpoint (not including NA&#39;s&hellip;that will actually be very important):</p>

<pre><code class="r">maxEndPoints &lt;- apply(endPointData, 1, max, na.rm=TRUE) 
minEndPoints &lt;- apply(endPointData, 1, min, na.rm=TRUE)

maxMinSummary &lt;- cbind(endPoint[,c(&quot;chnm&quot;, &quot;casn&quot;, &quot;Units&quot;)], 
                       maxEndPoint=maxEndPoints, 
                       minEndPoint=minEndPoints)
</code></pre>

<p>The next task is to determine if the method quantitation limit (MQL) or minimum level of detectability (MLD) are going to tell us anything in relation to the ToxCast endpoints. Likewise, we can look at the maximum and minimum measured values.</p>

<pre><code class="r">maxMeasure &lt;- apply(passiveData[,siteColumns], 1, max, na.rm=TRUE) 
minMeasure &lt;- apply(passiveData[,siteColumns], 1, min, na.rm=TRUE)
dataSummary &lt;- passiveData[,-siteColumns]
dataSummary$Max &lt;- maxMeasure
dataSummary$Min &lt;- minMeasure

maxMinSummary &lt;- left_join(maxMinSummary,dataSummary, 
                           by=c(&quot;casn&quot;=&quot;CAS&quot;, &quot;Units&quot;=&quot;Units&quot;))
</code></pre>

<p>If any of the MLD are higher than the maxEndPoint, we wouldn&#39;t be able to make any conclusions about the toxicity of the water:</p>

<pre><code class="r">sum(maxMinSummary$MLD &gt; maxMinSummary$maxEndPoint)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<p>It will also be interesting to know if any of the maximum measured values are greater than the minimum endpoint values:</p>

<pre><code class="r">sum(maxMinSummary$Max &gt; maxMinSummary$minEndPoint)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<p>Most likely, those will be the most interested cases:</p>

<table><thead>
<tr>
<th align="left"></th>
<th align="left">chnm</th>
<th align="left">casn</th>
<th align="left">Units</th>
<th align="right">maxEndPoint</th>
<th align="right">minEndPoint</th>
<th align="right">MLD</th>
<th align="right">MQL</th>
<th align="right">Max</th>
<th align="right">Min</th>
</tr>
</thead><tbody>
<tr>
<td align="left">7</td>
<td align="left">Erythromycin</td>
<td align="left">114-07-8</td>
<td align="left">ng/L</td>
<td align="right">75092316</td>
<td align="right">6.959</td>
<td align="right">0.128</td>
<td align="right">0.638</td>
<td align="right">11.735</td>
<td align="right">1.192</td>
</tr>
<tr>
<td align="left">52</td>
<td align="left">Cotinine</td>
<td align="left">486-56-6</td>
<td align="left">ng/L</td>
<td align="right">25061887</td>
<td align="right">11.444</td>
<td align="right">0.468</td>
<td align="right">2.338</td>
<td align="right">19.840</td>
<td align="right">4.924</td>
</tr>
<tr>
<td align="left">54</td>
<td align="left">Aspirin</td>
<td align="left">50-78-2</td>
<td align="left">ng/L</td>
<td align="right">29504608</td>
<td align="right">13.548</td>
<td align="right">0.424</td>
<td align="right">2.122</td>
<td align="right">14.991</td>
<td align="right">2.504</td>
</tr>
<tr>
<td align="left">83</td>
<td align="left">Fluorene</td>
<td align="left">86-73-7</td>
<td align="left">pg/L</td>
<td align="right">27171274907</td>
<td align="right">1680.889</td>
<td align="right">100.000</td>
<td align="right">400.000</td>
<td align="right">15000.000</td>
<td align="right">120.000</td>
</tr>
</tbody></table>

<h3>Data Analysis</h3>

<p>Let&#39;s start our analysis with one site (the first of the site columns: site04101500):</p>

<pre><code class="r">commonColumns &lt;- c(&quot;Chemical&quot;, &quot;Units&quot;, 
                  &quot;MLD&quot;, &quot;MQL&quot;, &quot;CAS&quot;, &quot;mlWt&quot;)
oneSite &lt;- passiveData[,c(commonColumns, &quot;site04101500&quot;)]


oneSite &lt;- rename(oneSite, value = site04101500)
head(oneSite)
</code></pre>

<pre><code>##                    Chemical Units MLD  MQL        CAS     mlWt value
## 1               Trifluralin  pg/L 190  490  1582-09-8 335.2823    NA
## 2   Hexachlorobenzene (HCB)  pg/L  32   88   118-74-1 284.7840   130
## 3  Pentachloroanisole (PCA)  pg/L  69  210  1825-21-4 280.3651   150
## 4                Tefluthrin  pg/L 130  380 79538-32-2 418.7382    NA
## 5 alpha-Benzenehexachloride  pg/L 190  570   319-85-6       NA    NA
## 6                   Lindane  pg/L 850 2400    59-89-9       NA    NA
</code></pre>

<p>We can now look at the ratio of the measured data to the endpoints:</p>

<pre><code class="r">casnRow &lt;- setNames(1:nrow(oneSite),oneSite$CAS)

ratioPassive &lt;- oneSite[casnRow[endPoint$casn],&quot;value&quot;] / endPointData

maxRatio &lt;- suppressWarnings(max(apply(ratioPassive[,siteColumns], 1, max, na.rm=TRUE) ))
</code></pre>

<p>So for the passive dataset, the maximum ratio of the measured data to the endpoints for all chemicals at the first site is 0.0024879.</p>

<h3>Water Sample Data:</h3>

<p>The data returned from water sample tests was returned in a &#39;wide&#39; format:</p>

<pre><code class="r">packagePath &lt;- system.file(&quot;extdata&quot;, package=&quot;toxEval&quot;)
filePath &lt;- file.path(packagePath, &quot;waterSamples.RData&quot;)
load(file=filePath)

head(waterSamples[,1:10])
</code></pre>

<pre><code>##   ActivityStartDateGiven          site ActivityEndDateGiven qualifier_04254 valueToUse_04254
## 1    2010-09-13 11:15:00 USGS-04101500                 &lt;NA&gt;            &lt;NA&gt;               NA
## 2    2010-09-13 12:30:00 USGS-04032000                 &lt;NA&gt;            &lt;NA&gt;               NA
## 3    2010-09-13 13:15:00 USGS-04102500                 &lt;NA&gt;            &lt;NA&gt;               NA
## 4    2010-09-13 14:30:00 USGS-04040000                 &lt;NA&gt;            &lt;NA&gt;               NA
## 5    2010-09-13 16:30:00 USGS-04043000                 &lt;NA&gt;            &lt;NA&gt;               NA
## 6    2010-09-14 07:10:00 USGS-04119400  2010-10-12 08:35:00               &lt;              0.1
##   val_qual_tx_04254 meth_cd_04254 dqi_cd_04254 detectionLimit_04254 rpt_lev_cd_04254
## 1              &lt;NA&gt;          &lt;NA&gt;         &lt;NA&gt;                   NA             &lt;NA&gt;
## 2              &lt;NA&gt;          &lt;NA&gt;         &lt;NA&gt;                   NA             &lt;NA&gt;
## 3              &lt;NA&gt;          &lt;NA&gt;         &lt;NA&gt;                   NA             &lt;NA&gt;
## 4              &lt;NA&gt;          &lt;NA&gt;         &lt;NA&gt;                   NA             &lt;NA&gt;
## 5              &lt;NA&gt;          &lt;NA&gt;         &lt;NA&gt;                   NA             &lt;NA&gt;
## 6                           GCM99            S                  0.2              IRL
</code></pre>

<p>The first job is to once again find the unique units. This data is arranged by a 5 digit USGS parameter code. Using the <strong>dataRetrieval</strong> package, information about the parameter codes can be retrieved. Each parameter code has 6 columns: detectionLimit, rep_lev_cd, qualifier, valueToUse, val_qual_tex, meth_cd, dqi_cd. We can pull out one of those columns to find the unique paremeter codes:</p>

<pre><code class="r">library(dataRetrieval)

waterSamplePCodes &lt;- names(waterSamples)[grep(&quot;valueToUse&quot;, names(waterSamples))]
waterSamplePCodes &lt;- sapply(strsplit(waterSamplePCodes, &quot;_&quot;), function(x) x[2])

pCodeInfo &lt;- readNWISpCode(waterSamplePCodes)

unique(pCodeInfo$parameter_units)
</code></pre>

<pre><code>## [1] &quot;ug/l&quot;
</code></pre>

<p>In this dataset, all the data is reported in ug/l. Our conversion therefore is:</p>

<p>\[
\require{cancel}
\begin{aligned}
Reported Data = \log \mu M \
\mu M = 10^{\log \mu M} \
MW = \frac{g}{mol} , M = \frac{mol}{L}  \
\cancel{\mu M} \left[\frac{\cancel{M}}{10^6 \cancel{\mu M}}\right] \left[\frac{1}{\cancel{M}}  \frac{\cancel{mol}}{L}\right] \left[ \frac{MW \cancel{g}}{\cancel{mol}}\right] \left[\frac{10^6 \mu g}{\cancel{g}}\right] = MW * \frac{\mu g}{L} 
\end{aligned}
\]</p>

<pre><code class="r">AC50 &lt;- left_join(AC50gain, passiveData[,c(&quot;CAS&quot;, &quot;Units&quot;, &quot;mlWt&quot;)],
                   by= c(&quot;casn&quot; = &quot;CAS&quot;)) %&gt;%
  filter(!is.na(Units)) %&gt;%
  rename(desiredUnits = Units) %&gt;%
  mutate(conversion = mlWt) %&gt;%
  select(casn, chnm, desiredUnits, mlWt, conversion)
</code></pre>

<p>Next we can create a data frame with the AC50 converted endpoints:</p>

<pre><code class="r">AC50Converted &lt;- left_join(AC50, AC50gain)
</code></pre>

<pre><code>## Joining by: c(&quot;casn&quot;, &quot;chnm&quot;)
</code></pre>

<pre><code class="r">infoColumns &lt;- c(&quot;casn&quot;, &quot;chnm&quot;, &quot;desiredUnits&quot;,&quot;mlWt&quot;, &quot;conversion&quot;, &quot;code&quot;,&quot;chid&quot;)

endPointData &lt;- AC50Converted[,!(names(AC50Converted) %in% infoColumns)]
endPointData &lt;- 10^endPointData
endPointData &lt;- endPointData * AC50Converted$conversion
endPoint &lt;- cbind(AC50, data.frame(endPointData))
endPoint &lt;- rename(endPoint, Units=desiredUnits)
</code></pre>

<p>First, let&#39;s look at the extreme reported endpoint (not including NA&#39;s&hellip;that will actually be very important):</p>

<pre><code class="r">maxEndPoints &lt;- apply(endPointData, 1, max, na.rm=TRUE) 
minEndPoints &lt;- apply(endPointData, 1, min, na.rm=TRUE)

maxMinSummary &lt;- cbind(endPoint[,c(&quot;chnm&quot;, &quot;casn&quot;, &quot;Units&quot;)], 
                       maxEndPoint=maxEndPoints, 
                       minEndPoint=minEndPoints)
</code></pre>

<p>The next task is to determine if the detectionLimit is going to tell us anything in relation to the ToxCast endpoints. Likewise, we can look at the maximum and minimum measured values.</p>

</body>

</html>
