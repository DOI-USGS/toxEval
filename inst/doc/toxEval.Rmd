---
title: "Introduction to toxEval"
author: "Steven R. Corsi, Laura A. De Cicco"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Introduction to toxEval}
  \usepackage[utf8]{inputenc}
---


```{r setup, include=FALSE}
options(continue=" ")
options(width=100)
library(knitr)
library(rmarkdown)


```

# Introduction

This package **toxEval** is an early test version of the package that will encompass the various approaches to evaluate ToxCast data in relation to measured aquatic concentrations.

## Molecular weights
ToxCast reports values in $\log$$\mu$M. Data from water samples collected are typically mg/L, ng/L, or pg/L. Therefore, the first step is to determine the molecular weight of the measured data. The package **webchem** supports this functionality. 


```{r}

library("webchem")

molweight <- cir_query('3380-34-5', "mw")
molweight

```


Data measured in aquatic environments can come in many different formats. This package will use example data measured from passive samplers, as well as water samples taken at a variety of sites around the Great Lakes. 

## Passive Data
Passive data was returned from the laboratory in a 'long' format. A sample of the data is shown below:

```{r echo=TRUE, eval=TRUE}

packagePath <- system.file("extdata", package="toxEval")
filePath <- file.path(packagePath, "passiveData.RData")
load(file=filePath)
#Site Info:
filePath <- file.path(packagePath, "stationINFO.RData")
load(file=filePath)

# Some chemicals have 2 rows (different units)...
# To simplify for now, we'll ignore the duplicate chemicals:
passiveData <- passiveData[!duplicated(passiveData$CAS),]

head(passiveData[,1:7])

# Unique units:
unique(passiveData$Units)

```

For this data, the CAS column was used to retrieve the molecular weight (mlWt). Each column is a unique site where the data was collected. Each row is a unique measured chemical. 

Some of the data is 'left-censored'. This means that the measured data was lower than the detection limit of the measurement technique. Values that are found to be lower than the detection limit are indicated by a "<". The first thing to check is that the method quantitation limit (MQL) or minimum level of detectability (MLD) are low enough to be ignored. That is, MQL and MLD are below the minumum endpoint levels. If so, we can simply remove any values that have the "<" indicator. To begin the study of the endpoints and how they relate to our data, we need to load up the **toxEval** package, and choose an endpoint dataset. We will use the AC50gain dataset in this report.

For this workflow, we will use the units reported by the measured data, meaning we need to convert the ToxCast end points to the units in the "Units" column of the passiveData data frame (we could also do the analysis converting the measured data to $\log$$\mu$M... it shouldn't matter as long as you are consistent).

```{r message=FALSE}
library(toxEval)

# AC50 data provided in the toxEval package:
AC50gain <- AC50gain
head(AC50gain[,1:5])

```

The units in the AC50gain, AC50loss, and AC10 data sets are $\log$$\mu$M. The first step is to convert to the desired unit (`r unique(passiveData$Units)`) based on the passiveData data frame.

$$
\require{cancel}
\begin{aligned}
Reported Data = \log \mu M \\
\mu M = 10^{\log \mu M} \\
MW = \frac{g}{mol} , M = \frac{mol}{L}  \\
\cancel{\mu M} \left[\frac{\cancel{M}}{10^6 \cancel{\mu M}}\right] \left[\frac{1}{\cancel{M}}  \frac{\cancel{mol}}{L}\right] \left[ \frac{MW \cancel{g}}{\cancel{mol}}\right] \left[\frac{10^9 ng}{\cancel{g}}\right] = MW * 10^3 \frac{ng}{L} 
\end{aligned}
$$

```{r message=FALSE}
library(dplyr)

unitConversion <- setNames(c(10^6, 10^3), c("pg/L", "ng/L") )

AC50 <- right_join(AC50gain[,c("casn"), drop=FALSE], 
                   passiveData[,c("CAS", "Units", "mlWt")],
                   by= c("casn" = "CAS")) %>%
  rename(desiredUnits = Units) %>%
  filter(!is.na(mlWt)) %>%
  mutate(conversion = unitConversion[desiredUnits] * mlWt) %>%
  select(casn, desiredUnits, mlWt, conversion)

```

A sample of the AC50 data frame is shown here:

```{r echo=FALSE}
kable(head(AC50), digits=2, row.names = FALSE)

```

Next we can create a data frame with the AC50 converted endpoints:
```{r}
AC50Converted <- left_join(AC50, AC50gain)
infoColumns <- c("casn", "chnm", "desiredUnits","mlWt", "conversion", "code","chid")

endPointData <- AC50Converted[,!(names(AC50Converted) %in% infoColumns)]
endPointData <- 10^endPointData
endPointData <- endPointData * AC50Converted$conversion
endPoint <- cbind(AC50, data.frame(endPointData)) %>%
  rename(Units=desiredUnits) %>%
  filter(rowSums(is.na(endPointData)) != ncol(endPointData))

endPointData <- endPointData[rowSums(is.na(endPointData)) != 
                               ncol(endPointData),]
```

Now, let's look at the extreme reported endpoint (not including `r NA`'s):

```{r warning=FALSE}
maxEndPoints <- apply(endPointData, 1, max, na.rm=TRUE) 
minEndPoints <- apply(endPointData, 1, min, na.rm=TRUE)

maxMinSummary <- cbind(endPoint[,c("casn", "Units")], 
                       maxEndPoint=maxEndPoints, 
                       minEndPoint=minEndPoints) %>%
  arrange(desc(casn))

```

Next, let's determine if the MQL or MLD are going to tell us anything in relation to the ToxCast endpoints. Likewise, we can look at the maximum and minimum measured values.

```{r warning=FALSE}
siteColumns <- grep("site",names(passiveData))
maxMinSummary <- left_join(maxMinSummary,passiveData[,-siteColumns], 
                           by=c("casn"="CAS", "Units"="Units")) 

```

If any of the MLD are higher than the maxEndPoint, we wouldn't be able to make any conclusions about the toxicity of the water:

```{r}
sum(maxMinSummary$MLD > maxMinSummary$minEndPoint)

```

So, `r sum(maxMinSummary$MLD > maxMinSummary$maxEndPoint)` measurements have detection limitations that are greater than the minimum endpoint concentration. We might be interested to know how close the detection limit values come to the minimum endpoints. 

The following chemicals have MLD's within 1% of the miniumum endpoint value:

```{r echo=FALSE}
dfToPrint <- mutate(maxMinSummary, MLD_EAR = MLD*100/minEndPoint) %>%
  filter(MLD_EAR > 1) %>%
  select(Chemical, minEndPoint, MLD, MLD_EAR) %>%
  arrange(desc(MLD_EAR)) %>%
  rename("Max EAR [%]"=MLD_EAR)
  
kable(dfToPrint, digits=2)
```

Since it appears that we can ignore the censored values, the easist way to convert data to numbers then is to use the `as.numeric` function. This will convert the left-censored data to `NA`, generating a warning. To convert all the columns with the word 'site' in their column name to numeric, use the following commands:

```{r warning=FALSE}
siteColumns <- grep("site",names(passiveData))
passiveData[,siteColumns] <- sapply(passiveData[,siteColumns], function(x) as.numeric(x))

#For this analysis, we'll consider NA's to be 0 (other options exist):
passiveData[,siteColumns][is.na(passiveData[,siteColumns])] <- 0

```

Now let's check if the maximum measured values are greater than the minimum endpoint values:


```{r }
siteKey <- setNames(stationINFO$shortName, stationINFO$STAID)

dataSummary <- select(passiveData, CAS, Units) %>%
  mutate(maxMeasure = apply(passiveData[,siteColumns], 1, max, na.rm=TRUE)) %>%
  mutate(minMeasure = apply(passiveData[,siteColumns], 1, min, na.rm=TRUE)) %>%
  mutate(maxIndex = apply(passiveData[,siteColumns], 1, which.max)) %>%
  mutate(site = gsub("site","",names(passiveData[,siteColumns])[maxIndex])) %>%
  mutate(shortname = siteKey[site])

maxMinSummaryNew <- left_join(maxMinSummary, dataSummary, 
                              by=c("casn" = "CAS", "Units"="Units")) %>%
  mutate(EAR = maxMeasure*100/minEndPoint) %>%
  filter(EAR > 10) %>%
  arrange(desc(EAR)) %>%
  select(Chemical, minEndPoint, maxMeasure, EAR, shortname) %>%
  rename("EAR [%]"=EAR, "Station"=shortname)
  

kable(maxMinSummaryNew, digits=2)


```

For now, let's focus on the minumum endpoint for each chemical. Later, we can decide to choose some other method for determining endpoints. 

```{r echo=TRUE}
endPointSummary <- select(endPoint, casn, Units) %>%  
  mutate(minEndPoint = apply(endPointData, 1, min, na.rm=TRUE)) %>%
  #Other filters would be done here (for example, only ATG, or find the closest)
  mutate(endPoint = colnames(endPointData)[apply(endPointData, 1, which.min)]) %>% 
  filter(casn %in% passiveData$CAS &
           Units %in% passiveData$Units) %>%
  slice(match(passiveData$CAS, casn)[!is.na(match(passiveData$CAS, casn))]) 
# kable(head(endPointSummary), digits=2)

```

### Data Analysis
Let's start our analysis with one site (the first of the site columns: `r siteKey["04101500"]`):

```{r message=FALSE}
commonColumns <- c("Chemical", "Units", 
                  "MLD", "MQL", "CAS", "mlWt")
oneSite <- passiveData[,c(commonColumns, "site04101500")]
oneSite <- rename(oneSite, value = site04101500)
head(oneSite)

```

We can now look at the ratio of the measured data to the endpoints:

```{r warning=FALSE}
passiveRatio <- right_join(oneSite, endPointSummary, 
                           by=c("CAS"="casn", "Units"="Units")) %>%
  mutate(EAR = value*100/minEndPoint)

  
```

So for the passive dataset, at `r siteKey["04101500"]`, the maximum ratio of the measured data to the endpoints for all chemicals at the first site is `r max(passiveRatio$EAR)` %.


Extending this to all sites:

```{r echo=TRUE, eval=TRUE, warning=FALSE}

siteColumns <- grep("site",names(passiveData))
passiveRatio <- right_join(passiveData, endPointSummary, 
                           by=c("CAS"="casn", "Units"="Units"))
passiveRatio[,siteColumns] <- passiveRatio[,siteColumns]*100/passiveRatio$minEndPoint

maxKey <- setNames(apply(passiveRatio[,siteColumns], 2, max),
                   gsub("site","", names(passiveRatio[,siteColumns])))
chemKey <- setNames(passiveRatio$Chemical[apply(passiveRatio[,siteColumns], 2, which.max)],
                   gsub("site","", names(passiveRatio[,siteColumns])))

maxRatioBySite <-  data.frame(site=names(passiveData)[siteColumns],
                             stringsAsFactors=FALSE) %>%
  mutate(shortName = siteKey[gsub("site","",site)]) %>%
  mutate(maxRatio = maxKey[gsub("site","",site)]) %>%
  mutate(Chemical = chemKey[gsub("site","",site)]) %>%
  filter(maxRatio > 50) %>%
  arrange(desc(maxRatio)) %>%
  select(shortName, maxRatio, Chemical) %>%
  rename(Station=shortName, "Max Ratio [%]"=maxRatio)
 
kable(maxRatioBySite, digits=2, row.names = FALSE)

```

So for the passive dataset, the maximum ratio of the measured data to the endpoints for all chemicals at all sites is `r maxRatioBySite[1,2]`, at site `r maxRatioBySite[1,1]`, from `r maxRatioBySite[1,3]`, based on endpoint `r maxRatioBySite[1,4]`.


## Water Sample Data
The data returned from water sample tests was returned in a 'wide' format:

```{r echo=FALSE}

#Clear out local enviornment:
rm(AC50, dataSummary, dfToPrint,endPoint,
   endPointData, maxMinSummary, maxMinSummaryNew, maxRatioBySite,
   oneSite, passiveData,  commonColumns, filePath,
   infoColumns, maxEndPoints,
   minEndPoints, packagePath, siteColumns,unitConversion)

```

```{r echo=TRUE, eval=TRUE}
packagePath <- system.file("extdata", package="toxEval")
filePath <- file.path(packagePath, "waterSamples.RData")
load(file=filePath)

head(waterSamples[,1:10])

```

The first job is to once again find the unique units. This data is arranged by a 5 digit USGS parameter code. Using the **dataRetrieval** package, information about the parameter codes can be retrieved. Each parameter code has 6 columns: detectionLimit, rep_lev_cd, qualifier, valueToUse, val_qual_tex, meth_cd, dqi_cd. We can pull out one of those columns to find the unique paremeter codes, then use **webchem** to get the molecular weights.

```{r message=FALSE, eval=FALSE}
library(dataRetrieval)

waterSamplePCodes <- names(waterSamples)[grep("valueToUse", names(waterSamples))]
waterSamplePCodes <- sapply(strsplit(waterSamplePCodes, "_"), function(x) x[2])

pCodeInfo <- readNWISpCode(waterSamplePCodes)

unique(pCodeInfo$parameter_units)

library(webchem)
pCodeInfo$mlWt <- rep(NA, nrow(pCodeInfo))
pCodeInfo$mlWt[pCodeInfo$casrn != ""] <- sapply(pCodeInfo$casrn[pCodeInfo$casrn != ""],
                function(x) cir_query(x, "mw", first = TRUE))
pCodeInfo$mlWt <- as.numeric(pCodeInfo$mlWt)

```

```{r message=FALSE, echo=FALSE}
packagePath <- system.file("extdata", package="toxEval")
filePath <- file.path(packagePath, "pCodeInfo.RData")
load(file=filePath)

pCodeInfo <- pCodeInfo[pCodeInfo$casrn != "", ]

waterSamplePCodes <- names(waterSamples)[grep("valueToUse", names(waterSamples))]
waterSamplePCodes <- sapply(strsplit(waterSamplePCodes, "_"), function(x) x[2])



```

In this dataset, all the data is reported in `r unique(pCodeInfo$parameter_units)`. Our conversion therefore is:

$$
\require{cancel}
\begin{aligned}
Reported Data = \log \mu M \\
\mu M = 10^{\log \mu M} \\
MW = \frac{g}{mol} , M = \frac{mol}{L}  \\
\cancel{\mu M} \left[\frac{\cancel{M}}{\cancel{10^6} \cancel{\mu M}}\right] \left[\frac{1}{\cancel{M}}  \frac{\cancel{mol}}{L}\right] \left[ \frac{MW \cancel{g}}{\cancel{mol}}\right] \left[\frac{\cancel{10^6} \mu g}{\cancel{g}}\right] = MW * \frac{\mu g}{L} 
\end{aligned}
$$

```{r}

AC50 <- left_join(AC50gain, pCodeInfo[,c("casrn", "parameter_units", "mlWt")],
                   by= c("casn"="casrn")) %>%
  filter(!is.na(parameter_units)) %>%
  rename(desiredUnits = parameter_units) %>%
  mutate(conversion = mlWt) %>%
  select(casn, chnm, desiredUnits, mlWt, conversion)

```

Next we can create a data frame with the AC50 converted endpoints:
```{r}
AC50Converted <- left_join(AC50, AC50gain)
infoColumns <- c("casn", "chnm", "desiredUnits","mlWt", "conversion", "code","chid")

endPointData <- AC50Converted[,!(names(AC50Converted) %in% infoColumns)]
endPointData <- 10^endPointData
endPointData <- endPointData * AC50Converted$conversion
endPoint <- cbind(AC50, data.frame(endPointData))
endPoint <- rename(endPoint, Units=desiredUnits)

```

First, let's look at the extreme reported endpoint (not including `r NA`'s...that will actually may be important):

```{r warning=FALSE}
maxEndPoints <- apply(endPointData, 1, max, na.rm=TRUE) 
minEndPoints <- apply(endPointData, 1, min, na.rm=TRUE)

maxMinSummary <- cbind(endPoint[,c("chnm", "casn", "Units")], 
                       maxEndPoint=maxEndPoints, 
                       minEndPoint=minEndPoints)

```

The next task is to determine if the detectionLimit is going to tell us anything in relation to the ToxCast endpoints. Likewise, we can look at the maximum and minimum measured values.

```{r }
pCodeSummary <- select(pCodeInfo, srsname, casrn, parameter_units, mlWt)

detectionLimits <- waterSamples[,grep("detectionLimit", names(waterSamples))]
detectionLimits <- na.omit(detectionLimits)

# Check if any change over time:
all(apply(detectionLimits, 2, function(x) length(unique(x))==1))

#They do!

```

For now, we'll focus on the minimum detection level:
```{r warning=FALSE}
detLevels  <- data.frame(dl_pcode=names(detectionLimits),
                         minDetLevel=apply(detectionLimits, 2, min),
                         row.names=NULL, stringsAsFactors=FALSE) %>%
  mutate(pCode=sapply(strsplit(dl_pcode, "_"), function(x) x[2])) %>%
  left_join(pCodeInfo[c("parameter_cd","casrn")], by=c("pCode"="parameter_cd")) %>%
  select(casrn, pCode, minDetLevel) %>%
  right_join(maxMinSummary, by=c("casrn"="casn")) %>%
  mutate(EAR=minDetLevel/minEndPoint) %>%
  arrange(desc(EAR)) %>%
  filter(EAR > 0.1)

kable(detLevels, digits = 3)

```

This table shows us the chemicals that `r detLevels$chnm` may lead to issues since the detection levels are higher than some of the end point values.

In this case therefore, we cannot simply ignore all of the left-censored values. However, for the time being, we will use only non-censored values in our analysis. Let's begin by trimming down the waterSamples data frame to only the relavent information. Here, we are setting all left-censored values to NA, we could instead use the detection limit.

```{r}
qualColumns <- grep("qualifier", names(waterSamples))
valColumns <- grep("valueToUse", names(waterSamples))

waterData <- waterSamples[,valColumns]
waterData[waterSamples[,qualColumns] == "<"] <- NA

```

Now let's check how many maximum measured values are greater than the minimum endpoint values:

```{r echo=FALSE, warning=FALSE}

dataSummary  <- data.frame(pcode=names(waterData),
                         maxValue=apply(waterData, 2, max, na.rm=TRUE),
                         row.names=NULL, stringsAsFactors=FALSE)  %>%
  mutate(pCode=sapply(strsplit(pcode, "_"), function(x) x[2])) %>%
  left_join(pCodeInfo[c("parameter_cd","casrn")], by=c("pCode"="parameter_cd")) %>%
  select(casrn, pCode, maxValue) %>%
  right_join(maxMinSummary, by=c("casrn"="casn")) %>%
  mutate(EAR=maxValue/minEndPoint) %>%
  arrange(desc(EAR)) %>%
  filter(EAR > 1)
  

kable(dataSummary, digits=3)

```


### Data Analysis
Let's start our analysis with one site on one day (the first reported the site: USGS-04101500, on 2010-09-13):

```{r message=FALSE}

#Let's get rid of rows with all NA's:
naRows <- rowSums(is.na(waterData))!= ncol(waterData)
waterData <- waterData[naRows,]
waterSamples <- waterSamples[naRows,]

oneSite <- cbind(waterSamples[,1:2],waterData) %>%
  filter(site=="USGS-04101500") 

valColumns <- grep("valueToUse",names(oneSite))

oneSiteLong <- data.frame(pcode=names(oneSite[,valColumns]),
                         value=as.numeric(oneSite[1,valColumns]),
                         row.names=NULL, stringsAsFactors=FALSE) %>%
  mutate(pCode=sapply(strsplit(pcode, "_"), function(x) x[2])) %>%
  left_join(pCodeInfo[c("parameter_cd","casrn")], by=c("pCode"="parameter_cd")) %>%
  select(casrn, pCode, value) %>%
  right_join(maxMinSummary, by=c("casrn"="casn")) %>%
  filter(!is.na(value)) %>%
  mutate(EAR=100*value/minEndPoint) %>%
  arrange(desc(EAR)) %>%
  rename("Ratio [%]"=EAR)
  
kable(oneSiteLong, digits=3)

```

We can extend our analsis to all sites and all times. Probably the easiest way to accomplish this is to maintain the waterSamples data structure, but replace the measured values with measured values over minimum endpoint values.

```{r}
# First, we need to know what CAS is associated with which column:
pCodeLookup <- setNames(pCodeInfo$casrn, pCodeInfo$parameter_cd)

columnCAS <- setNames(names(waterData), 
                      pCodeLookup[sapply(strsplit(names(waterData), "_"), 
                                         function(x) x[2])])
                      
# Next, let's remove the columns that don't have toxCast data:
columnsInToxCast <- columnCAS[AC50gain$casn][!is.na(columnCAS[AC50gain$casn])]
waterRatio <- waterData[,columnsInToxCast]
waterRatio <- waterRatio[,]

#Get rid of rows with all NA's:
naRows <- rowSums(is.na(waterRatio))!= ncol(waterRatio)
waterRatio <- waterRatio[naRows,]
waterSamplesRatio <- waterSamples[naRows,]

# Finally, divide the minimum endpoint with the value:
for(i in 1:ncol(waterRatio)){
  CAS <- names(columnsInToxCast)[i]
  waterRatio[,i] <- waterRatio[,i] / maxMinSummary$minEndPoint[maxMinSummary$casn == CAS]
}

waterRatio <- cbind(waterSamplesRatio[,1:2], waterRatio)

```

So, what does this mean? Let's pull out one sample, and find out which endpoints are the critical endpoints for each chemical.

```{r}


```

### Relavent Censored Values
Remember that `r detLevels$chnm` have detection limits higher than at least one reported end point.

